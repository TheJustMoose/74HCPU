--------------------------------------|f|
|    |   4   +   3 + 1 + 3  +    5    |l|
|HIGH|   HIGH BYTE    |   LOW BYTE    |a| * - меняем CF, HCF, ZF (результат сложения) == A-FLAGS (Arithm)
|BYTE|F E D C  B A 9 8 7 6 5 4 3 2 1 0|g| + - меняем LF, EQ, GF (результат сравнения) == C-FLAGS (Compare)
|----|--------------------------------|s|
| 00 |   ADD |  DST |C| SRC |-|Z|z|I|i|*| ADDI  R0, 1    // INC R0;
| 10 |  ADDC |  DST |C| SRC |F|Z|z|I|i|*| ADDCI R1, 0    // INCC R1;    // бит F нужен для команд -INC-, -DEC-, SUB, -INV-, NEG
| 20 |   AND |  DST |C| SRC |-|Z|z|I|i|*| ANDI R2, 0x0F  // здесь есть свободный бит, и вместо F туда можно положить S[WAP] или S[HIFT]
| 30 |    OR |  DST |C| SRC |-|Z|z|I|i|*| ORI R3, 2      // в любом случае, сдвиг старшего нибла на место младшего кажется полезным
| 40 |   XOR |  DST |C| SRC |-|Z|z|I|i|*| XORI R4, 4     // кстати, в этом случае можно ещё и от команды SWAP избавиться
| 50 |   MUL |  DST |C| SRC |-|Z|z|I|i|*| MULI R6, 10    // R7:R6 := R6*10
| 60 |   UNO |  DST |0|-|TYP|F|-|-|-|-|*| унарные команды не используют операнд SRC, поэтому нельзя использовать инверторы и отдельные нибблы
| 70 |   MOV |  DST |0| SRC |*|Z|z|I|i| | MOVI R5, 5     // LDI R5, 5       // * - можно использовать, чтобы пихать адрес в SPL/SPH (правда, только из других регистров), или для того, чтобы сделать MOVW
| 80 |   LPM |  DST |0|EXT|D|U|-|-|-|W| | LPM R0, [IX]   // LPM R1, X   // LPM R1, DX  // W - читать слово (1) или байт (0)  // LPM читает из ROM, который подключен к мультиплексорам напрямую, поэтому никакого offset нет :(
| 90 |    LD |  DST |V|EXT|D|U|OFFSET4| | LD R1, [-Y]    // LD R3, [+SP-1] ; POP R3    // V - читать из Video RAM, причём целиком слово
| A0 |    IN |  DST |  PORT   |Z|z|I|i| | IN R2, PIN1    // IN R2, ~PIN1 ; Ii - инвертировать порт перед чтением, Zz - занулять ниббл при чтении (или сделать отдельный IMASK?)
|----|--------------|4-3-2-1-0|-------|-| всё что ниже - не модифицирует регистры
|              2 1 0         4 3 для XOR-а оставлен только один бит, кажется, что нет принципиальной разницы, XOR-ить один ниббл, или оба (опять таки, ассемблер упрощается!)
| B0 |   OUT | PORT |C| SRC |PRT|X|O|o| | OUT PORT0, R2  // XOUT PORT0, R2 (вместо Oo можно сделать вчетверо больше регистров!)
| C0 |    ST |  SRC |V|EXT|D|U|OFFSET4| | ST [Y], R2     // ST [IX], R2     // ST [Y+2], R2   // ST [-SP], R2 ; PUSH R2  // V - писать в Video RAM, причём целиком слово
| D0 |   CMP |  DST |C| SRC |-|   -   |+| CMPI R3, 10    // CMP  R0, R2
| E0 |  CMPC |  DST |C| SRC |-|   -   |+| CMPCI R4, 10   // CMPC R1, R3
| F0 | BRNCH |  CALL  | 8 bit OFFSET  | | переход в +-127 команды, значение прибавляется к текущему счётчику команд
| F1 | BRNCH |   JMP  | 8 bit OFFSET  | | <- COP low nibble
| F2 | BRNCH |   RET  | 8 bit +STACK  | | на сколько байт переместить указатель стека данных, дабы пропустить запушенные параметры
| F3 | BRNCH |  RETI  | 8 bit OFFSET  | | RETI           // однако, у меня нет механизма для переставления SP на несколько байт за команду RET
| F4 | BRNCH |    JL  | 8 bit OFFSET  | | if (v < w)     // поэтому вместо константы можно воткнуть сюда битик указания на RETI, вместо RET
| F5 | BRNCH |    JE  | 8 bit OFFSET  | | if (v == w)    // а не правильней ли будет сделать JLE вдобавок к отдельным JL + JE ?
| F6 | BRNCH |   JNE  | 8 bit OFFSET  | | if (v != w)
| F7 | BRNCH |    JG  | 8 bit OFFSET  | | if (v > w)     // с другой стороны, эту инструкцию можно эмулировать программно
| F8 | BRNCH |    JZ  | 8 bit OFFSET  | | if (v == 0)    // путём переставления регистров и использования JL
| F9 | BRNCH |   JNZ  | 8 bit OFFSET  | | if (v != 0)
| FA | BRNCH |    JC  | 8 bit OFFSET  | | if (CF == 1)
| FB | BRNCH |   JNC  | 8 bit OFFSET  | | if (CF == 0)   // выкинуть инструкции, что реально не будут использоваться
| FC | BRNCH |   JHC  | 8 bit OFFSET  | | if (HCF == 1)  // вкрутить что-то вроде NJMP offset (хотя текущий JMP так и делает?)
| FD | BRNCH |  JNHC  | 8 bit OFFSET  | | if (HCF == 0)  // (и делать реальный переход на offset*16, к примеру)
| FE | BRNCH | AFCALL | Hi 8 bit ADDR | | Absolute Far Call - 8 bit ADDR кладём в старшие биты и зануляем младшие
| FF | BRNCH |NOP/STOP|   1111 111x   | | NOP - хорошо бы чтоб имел код 0xFF, это позволит думать, что не прошитая память заполнена NOP-ами
--------------------------------------|-| если младший бит 0, то это STOP (отладочный стоп), плюс 7 бит на полёт фантазии
           0     1    2    3    4     5    6    7
 names: | HCF | CF | ZF | LF | ~EQ | GF | BF | -- | read only
